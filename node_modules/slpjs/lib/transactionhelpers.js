"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var __1 = require("..");
var bignumber_js_1 = require("bignumber.js");
var TransactionHelpers = /** @class */ (function () {
    function TransactionHelpers(slp) {
        this.slp = slp;
    }
    // Create raw transaction hex to: Send SLP tokens to one or more token receivers, include optional BCH only outputs
    TransactionHelpers.prototype.simpleTokenSend = function (tokenId, sendAmounts, inputUtxos, tokenReceiverAddresses, changeReceiverAddress, requiredNonTokenOutputs) {
        if (requiredNonTokenOutputs === void 0) { requiredNonTokenOutputs = []; }
        // normalize token receivers and amounts to array types
        if (typeof tokenReceiverAddresses === "string")
            tokenReceiverAddresses = [tokenReceiverAddresses];
        try {
            var amount = sendAmounts;
            amount.forEach(function (a) { return a.isGreaterThan(new bignumber_js_1.default(0)); });
        }
        catch (_) {
            sendAmounts = [sendAmounts];
        }
        if (sendAmounts.length !== tokenReceiverAddresses.length) {
            throw Error("Must have send amount item for each token receiver specified.");
        }
        // 1) Set the token send amounts, we'll send 100 tokens to a new receiver and send token change back to the sender
        var totalTokenInputAmount = inputUtxos
            .filter(function (txo) {
            return __1.Slp.preSendSlpJudgementCheck(txo, tokenId);
        })
            .reduce(function (tot, txo) {
            return tot.plus(txo.slpUtxoJudgementAmount);
        }, new bignumber_js_1.default(0));
        // 2) Compute the token Change amount.
        var tokenChangeAmount = totalTokenInputAmount.minus(sendAmounts.reduce(function (t, v) { return t = t.plus(v); }, new bignumber_js_1.default(0)));
        var txHex;
        if (tokenChangeAmount.isGreaterThan(new bignumber_js_1.default(0))) {
            // 3) Create the Send OP_RETURN message
            var sendOpReturn = this.slp.buildSendOpReturn({
                tokenIdHex: tokenId,
                outputQtyArray: __spread(sendAmounts, [tokenChangeAmount]),
            });
            // 4) Create the raw Send transaction hex
            txHex = this.slp.buildRawSendTx({
                slpSendOpReturn: sendOpReturn,
                input_token_utxos: __1.Utils.mapToUtxoArray(inputUtxos),
                tokenReceiverAddressArray: __spread(tokenReceiverAddresses, [changeReceiverAddress]),
                bchChangeReceiverAddress: changeReceiverAddress,
                requiredNonTokenOutputs: requiredNonTokenOutputs
            });
        }
        else if (tokenChangeAmount.isEqualTo(new bignumber_js_1.default(0))) {
            // 3) Create the Send OP_RETURN message
            var sendOpReturn = this.slp.buildSendOpReturn({
                tokenIdHex: tokenId,
                outputQtyArray: __spread(sendAmounts),
            });
            // 4) Create the raw Send transaction hex
            txHex = this.slp.buildRawSendTx({
                slpSendOpReturn: sendOpReturn,
                input_token_utxos: __1.Utils.mapToUtxoArray(inputUtxos),
                tokenReceiverAddressArray: __spread(tokenReceiverAddresses),
                bchChangeReceiverAddress: changeReceiverAddress,
                requiredNonTokenOutputs: requiredNonTokenOutputs
            });
        }
        else
            throw Error('Token inputs less than the token outputs');
        // Return raw hex for this transaction
        return txHex;
    };
    // Create raw transaction hex to: Send BCH to one or more receivers, makes sure tokens are not burned
    TransactionHelpers.prototype.simpleBchSend = function (sendAmounts, inputUtxos, bchReceiverAddresses, changeReceiverAddress) {
        // normalize token receivers and amounts to array types
        if (typeof bchReceiverAddresses === "string")
            bchReceiverAddresses = [bchReceiverAddresses];
        if (typeof sendAmounts === "string")
            sendAmounts = [sendAmounts];
        try {
            var amount = sendAmounts;
            amount.forEach(function (a) { return a.isGreaterThan(new bignumber_js_1.default(0)); });
        }
        catch (_) {
            sendAmounts = [sendAmounts];
        }
        if (sendAmounts.length !== bchReceiverAddresses.length) {
            throw Error("Must have send amount item for each token receiver specified.");
        }
        // 4) Create the raw Send transaction hex
        var txHex = this.slp.buildRawBchOnlyTx({
            input_token_utxos: __1.Utils.mapToUtxoArray(inputUtxos),
            bchReceiverAddressArray: bchReceiverAddresses,
            bchReceiverSatoshiAmounts: sendAmounts,
            bchChangeReceiverAddress: changeReceiverAddress
        });
        // Return raw hex for this transaction
        return txHex;
    };
    // Create raw transaction hex to: Create a token Genesis issuance
    TransactionHelpers.prototype.simpleTokenGenesis = function (tokenName, tokenTicker, tokenAmount, documentUri, documentHash, decimals, tokenReceiverAddress, batonReceiverAddress, bchChangeReceiverAddress, inputUtxos) {
        var genesisOpReturn = this.slp.buildGenesisOpReturn({
            ticker: tokenTicker,
            name: tokenName,
            documentUri: documentUri,
            hash: documentHash,
            decimals: decimals,
            batonVout: batonReceiverAddress ? 2 : null,
            initialQuantity: tokenAmount,
        });
        // 4) Create/sign the raw transaction hex for Genesis
        var genesisTxHex = this.slp.buildRawGenesisTx({
            slpGenesisOpReturn: genesisOpReturn,
            mintReceiverAddress: tokenReceiverAddress,
            batonReceiverAddress: batonReceiverAddress,
            bchChangeReceiverAddress: bchChangeReceiverAddress,
            input_utxos: __1.Utils.mapToUtxoArray(inputUtxos)
        });
        // Return raw hex for this transaction
        return genesisTxHex;
    };
    // Create raw transaction hex to: Create a NFT1 token Genesis issuance
    TransactionHelpers.prototype.simpleNFT1Genesis = function (tokenName, tokenTicker, parentTokenIdHex, tokenReceiverAddress, bchChangeReceiverAddress, inputUtxos) {
        var index = inputUtxos.findIndex(function (i) { return i.slpTransactionDetails.tokenIdHex === parentTokenIdHex; });
        var genesisOpReturn = this.slp.buildNFT1GenesisOpReturn({
            ticker: tokenTicker,
            name: tokenName,
            parentTokenIdHex: parentTokenIdHex,
            parentInputIndex: index
        });
        // 4) Create/sign the raw transaction hex for Genesis
        var genesisTxHex = this.slp.buildRawNFT1GenesisTx({
            slpNFT1GenesisOpReturn: genesisOpReturn,
            mintReceiverAddress: tokenReceiverAddress,
            bchChangeReceiverAddress: bchChangeReceiverAddress,
            input_utxos: __1.Utils.mapToUtxoArray(inputUtxos),
            parentTokenIdHex: parentTokenIdHex
        });
        // Return raw hex for this transaction
        return genesisTxHex;
    };
    // Create raw transaction hex to: Mint new tokens or move the minting baton
    TransactionHelpers.prototype.simpleTokenMint = function (tokenId, mintAmount, inputUtxos, tokenReceiverAddress, batonReceiverAddress, changeReceiverAddress) {
        // // convert address to cashAddr from SLP format.
        // let fundingAddress_cashfmt = bchaddr.toCashAddress(fundingAddress);
        // 1) Create the Send OP_RETURN message
        var mintOpReturn = this.slp.buildMintOpReturn({
            tokenIdHex: tokenId,
            mintQuantity: mintAmount,
            batonVout: 2
        });
        // 2) Create the raw Mint transaction hex
        var txHex = this.slp.buildRawMintTx({
            input_baton_utxos: __1.Utils.mapToUtxoArray(inputUtxos),
            slpMintOpReturn: mintOpReturn,
            mintReceiverAddress: tokenReceiverAddress,
            batonReceiverAddress: batonReceiverAddress,
            bchChangeReceiverAddress: changeReceiverAddress
        });
        //console.log(txHex);
        // Return raw hex for this transaction
        return txHex;
    };
    // Create raw transaction hex to: Burn a precise quantity of SLP tokens with remaining tokens (change) sent to a single output address
    TransactionHelpers.prototype.simpleTokenBurn = function (tokenId, burnAmount, inputUtxos, changeReceiverAddress) {
        // Set the token send amounts
        var totalTokenInputAmount = inputUtxos
            .filter(function (txo) {
            return __1.Slp.preSendSlpJudgementCheck(txo, tokenId);
        })
            .reduce(function (tot, txo) {
            return tot.plus(txo.slpUtxoJudgementAmount);
        }, new bignumber_js_1.default(0));
        // Compute the token Change amount.
        var tokenChangeAmount = totalTokenInputAmount.minus(burnAmount);
        var txHex;
        if (tokenChangeAmount.isGreaterThan(new bignumber_js_1.default(0))) {
            // Create the Send OP_RETURN message
            var sendOpReturn = this.slp.buildSendOpReturn({
                tokenIdHex: tokenId,
                outputQtyArray: [tokenChangeAmount],
            });
            // Create the raw Send transaction hex
            txHex = this.slp.buildRawBurnTx(burnAmount, {
                slpBurnOpReturn: sendOpReturn,
                input_token_utxos: __1.Utils.mapToUtxoArray(inputUtxos),
                bchChangeReceiverAddress: changeReceiverAddress
            });
        }
        else if (tokenChangeAmount.isLessThanOrEqualTo(new bignumber_js_1.default(0))) {
            // Create the raw Send transaction hex
            txHex = this.slp.buildRawBurnTx(burnAmount, {
                tokenIdHex: tokenId,
                input_token_utxos: __1.Utils.mapToUtxoArray(inputUtxos),
                bchChangeReceiverAddress: changeReceiverAddress
            });
        }
        else
            throw Error('Token inputs less than the token outputs');
        // Return raw hex for this transaction
        return txHex;
    };
    return TransactionHelpers;
}());
exports.TransactionHelpers = TransactionHelpers;
//# sourceMappingURL=transactionhelpers.js.map